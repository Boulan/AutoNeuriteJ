macro "AutoNeuriteJ_partIII [F1]" {
//////////////////////// Different measures : neurone cell body expansion /////////////////////////////////////////////////////


//////////////////////////////////Parameters/////////////////////////////////////////
minAxon=100; 				// Minimal length to be an axon (pixels)
minNeurite=10; 				// Minimal length to be a neurite (pixels)
ratio=2; 					// Minimal ratio between (mean primary neurite length) and (axonal length)--> Minimal ratio to be an axon

getDateAndTime(year, month, dayOfWeek, dayOfMonth, hour0, minute0, second, msec);





//////////////////////////stack opening 
defaultValue=1;
nombre_condition=getNumber("How many conditions do you have to analyze?", defaultValue);
 // Ask for the number of stack to be analysed
path=newArray(nombre_condition);
list=newArray(20);
	
Dialog.create("Parameter settings");
Dialog.addNumber("Minimal size to be a Neurite",minNeurite);
Dialog.addNumber("Minimal size to be an Axon",minAxon);
Dialog.addNumber("Ratio (Axon Length)/(Primary Neurites length) to be an Axon",ratio);
Dialog.show();
minNeurite=Dialog.getNumber();
minAxon=Dialog.getNumber();
ratio=Dialog.getNumber();
	
	
for (e=0; e<nombre_condition; e++) {                   // Ask for the directory of each stack to be analysed.
	path[e] = getDirectory("Choose a Directory");
}
	
for (e=0; e<nombre_condition; e++) {                                          // Files opening

////////////////////////// Sets information about the cells that will not be considered
number_Neurons=0;
connected_neurons=0;  // Sets the number of connected neurons that will be removed
SkelettooShort=0; // Sets the number of cells with too short skelet that will be removed


//////////////////////////////// Set Parameters to define Neurites and Axon


setBatchMode(true);



//////////NB: the file selected must contain any other folders than those who will be analysed (presence of other files isn't important)////


		
		open(path[e] + "/Stack_Body.tif");rename("Stack_Body");
		open(path[e] +  "/Stack_BodySkelet.tif");   rename("Stack_BodySkelet");  
		open(path[e] +  "/Stack_NoBodySkelet.tif");rename("Stack_NoBodySkelet");
		open(path[e] + "/Stack_Neuron_Original.tif");run("Enhance Contrast...", "saturated=0.3 normalize process_all use");rename("Stack_Neuron_Originale");


		setBackgroundColor(0, 0, 0);
		setForegroundColor(255, 255, 255);
		
		long_neurite=newArray(1000); type_neurite=newArray(1000);
	

//////////////////////////////// Prints Results Header ////////////////////////////////////////////////////////////////
				getDateAndTime(year, month, dayOfWeek, dayOfMonth, hour1, minute1, second, msec);
		print (hour1+"h:"+minute1);
		print(path[e]);
		print("minAxon="+minAxon);
		print("minNeurite="+minNeurite);
		print("ratio="+ratio);	
		print("Neuron# \t Primary Neurites # \t Neurite Order  \t Primary Neurites mean Length \t Neurite Length \t Longest Neurite Length \t Axonal Tree length \t Axonal Tree Branches #");
		
		
	run("Options...", "iterations=1 count=1 black do=Dilate stack");
	
				
		////////////////////////////////  Loop for each neuron to create trees of neurite ///////////////////////////////////////////////
		
		nb_neurones=nSlices;
		q=1;
		endNbNeuron=0; meanPrimaryLength=newArray(); meanPrimaryNumber=newArray();
		nbAxon=0;
		
		for(j=1;j<=nb_neurones;j++){
					
			selectWindow("Stack_NoBodySkelet");	setSlice(j); run("Duplicate...", "title=masque_arbres");	 // Neurites skeleton									
			selectWindow("Stack_BodySkelet"); setSlice(j); 	run("Duplicate...", "title=pointes"); run("Duplicate...", "title=S_et_S"); // used to detect neurites extremities
			selectWindow("Stack_Body");	setSlice(j);	run("Duplicate...", "title=CBS");			// Cell body of neuron number j									
			selectWindow("pointes"); 
			run("BinaryConnectivity ", "white");
			setThreshold(2, 2); run("Convert to Mask");												// Connectivity value correspond to ends of neurites
			run("Set Measurements...", "  bounding redirect=None decimal=3");
			run("Analyze Particles...", "size=0-Infinity circularity=0.00-1.00 show=Nothing display clear"); // Gives X and Y of each neurites end
			selectWindow("Results"); coordinates=getInfo();
			
			Nb_pointes =nResults;
			run("Clear Results");
		
/////////////// Search for each tree the longest branch without the ROI manager (too slow) ///////////////////////////////
		if(Nb_pointes==0){selectWindow("Stack_NoBodySkelet"); setSlice(j); run("Delete Slice");
						selectWindow("Stack_BodySkelet"); setSlice(j); run("Delete Slice");
						selectWindow("Stack_Body"); setSlice(j); run("Delete Slice");
						selectWindow("Stack_Neuron_Originale"); setSlice(j); run("Delete Slice");
						j=j-1;
						nb_neurones=nb_neurones-1;
						selectWindow("masque_arbres");close();
						selectWindow("S_et_S");close();					
						selectWindow("pointes");close();
						selectWindow("CBS");close();
						}
		else{
	
			grand_neurite = -1; neurite_majeur=-1;
			for(i=0;i<Nb_pointes;i++) {																// for each ends	
				type_neurite[i]=2; 																	// Neurite type: 1=axon, 2=neurite (Default), 3...=secondary branch (or more) 
				selectWindow("S_et_S"); 
				nom="Neurone_"+j+"_Neurite"+i+1;	run("Duplicate...", "title="+nom); 				// Create one image by neurite
				x=getCoordinate("BX", i); y=getCoordinate("BY", i);											// Coordinate of the ieme neurite end

				run ("Specify...", "width=2 height=2 x=" + x + " y=" + y + " centered"); 			// Trace a pruning protection around the neurite end
				setForegroundColor(255, 255, 255);                                      
				run("Fill", "slice"); 																// Filling of the selected area, paved on the end
				run("BinaryThin ", "kernel_a=[0 2 2 0 1 0 0 0 0 ] rotations=[rotate 45] iterations=-1 white"); 	// pruning
				imageCalculator("AND", nom,"masque_arbres");										// Image of Neurone_j_Neurite_i
				doWand(x, y,0.0,"8-connected");run("Clear Outside");	run("Fill", "slice");	run("Skeletonize");		// Potential cleaning of other neurons
				
				//selectWindow("Results");		IJ.renameResults("Results2");
				
				/////////////////// Measure of the length of the neurite using Analyze Skeleton plugins
				run("Analyze Skeleton (2D/3D)", "prune=none");
				selectWindow("Results");
				long_neurite[i]=getResult("Maximum Branch Length", 0);  // Length between the nucleus and the end
				close();	close("Tagged Skeleton");				

				//selectWindow("Results2");	IJ.renameResults("Results");
				
						
				if(long_neurite[i]>=neurite_majeur) {neurite_majeur=long_neurite[i]; grand_neurite=i;}				// Record the longest neurite
			}  

				
//********************************  Overlapping neurites Search*****************************************************************

//////////////// Comparison between Neurite i and i+1
				
			for(i=0;i<Nb_pointes-1;i++) {											// for each neurite i
				x=getCoordinate("BX", i); y=getCoordinate("BY", i); 						// Gets coordinates  
				nom="Neurone_"+j+"_Neurite"+i+1;									// Gets name		
				for(k=i+1;k<Nb_pointes;k++) {										// for each next neurite
					nom2="Neurone_"+j+"_Neurite"+k+1; 								// Gets name
					selectWindow(nom2); run("Select None");												// 
					selectWindow(nom);run("Select None");doWand(x, y, 0.0, "8-connected");				// Selects Neurite i
					selectWindow(nom2);	run("Restore Selection");					// overlay of selected neurite i in the image neurite k 
					getStatistics(area, mean);overlap=mean;							//  measures overlap between the two neurites
					
					if(overlap!=0) {												// If overlap exists
						if(long_neurite[i]>long_neurite[k]) {						//  if i length>k  
							type_neurite[k]=type_neurite[k]+1;						// Increase k type of neurite 
							imageCalculator("Subtract ", nom2, nom);				// reDraws k without overlap 
						}
									
						else {														//  if k length>i
							type_neurite[i]=type_neurite[i]+1;						// Increase i type of neurite reDraws i without overlap
							imageCalculator("Subtract ", nom, nom2);				// reDraws i without overlap				
							} // end else																								
					} // end if	overlap!=0					
				} // end for(k=i+1;k<Nb_pointes;k++)
			} // End neurites apparies

	/////////////////////////////  measure of neurite's length, and rank  //////////////////////////////////////////////////////////////
			grand=newArray(1000);	MoyPrim=0	; NbrPrim=0	;	NbrNeurite=0;	LongPrim=0;													// For mean length computation of primary
			for(i=0;i<Nb_pointes;i++){ 													            // for each neurite i
				nom="Neurone_"+j+"_Neurite"+i+1;selectWindow(nom);
				x=getCoordinate("BX", i); y=getCoordinate("BY", i);
				//selectWindow("Results");	IJ.renameResults("Results2");

				run("Analyze Skeleton (2D/3D)", "prune=none");
				area=getResult("Maximum Branch Length", 0);
				grand[i]=getResult("Maximum Branch Length", 0);
				
				close();
				close("Tagged Skeleton");

				//selectWindow("Results2");	IJ.renameResults("Results");

				if(i!= grand_neurite && area > minNeurite && type_neurite[i]==2){      
					NbrPrim=NbrPrim+1;
					LongPrim=LongPrim+area; 					  // Sum of primary segments, without the longest
					MoyPrim=LongPrim/(NbrPrim);                   // Mean of primary segments, without the longest
				}
			}
				

/////////////////////////////////////////Axon determination : potential axon vs major primary dendrite /////////////////////////////////////////////////////////////////////////////////////				
								
			if(neurite_majeur> minAxon) type_neurite[grand_neurite]=1;                             // If the longest primary exceeds the minimal length of axon, he is classed on axon.
				grand_primaire=1;
				for(i=0;i<Nb_pointes;i++){ 													       // For each neurite i
					if(grand_primaire <= grand[i] && grand[i]>minNeurite && type_neurite[i]==2) {  // If the primary dendrite is longer than the repertory longest primary dendrite  
						grand_primaire=grand[i];     						        	           // The primary becomes the longest repertory													   
						if(neurite_majeur< ratio*grand_primaire){ 								   // If the longest primary dendrite is not "ratio" times smaller than the primary longest neurite, this is declassified after, of axon to dendrite
							type_neurite[grand_neurite]=2;										   
						}
					}
				}
				if(type_neurite[grand_neurite]<=2){													// If axon, added to primary neurites stats (number, total length, mean length) 
					NbrPrim=NbrPrim+1;																
					LongPrim=LongPrim+neurite_majeur;
					MoyPrim=LongPrim /(NbrPrim); 
				}
////////////////////////////////////////////Results writing//////////////////////////////////////////////////////	
			
				for(i=0;i<Nb_pointes;i++){ 															// for each neurite i
					if(i != grand_neurite && grand[i]>minNeurite)
						print(j,"\t",NbrPrim, " \t ",type_neurite[i], "\t ",MoyPrim, "\t ", grand[i]);
	
					if(i == grand_neurite && grand[i]>minNeurite)
						print(j,"\t",NbrPrim, " \t ",type_neurite[i], "\t ",MoyPrim, "\t ", grand[i], "\t ", grand[i]); // Add of a column for the longuer primary neurite
					
				}
										
					
//**************************************Image Stack creation corresponding to neurite skeleton, quantified by color in function of their connections
				
				selectWindow("masque_arbres");close();
				selectWindow("S_et_S");close();					
				selectWindow("pointes");close();
				selectWindow("CBS");close();
				
				for(i=0;i<Nb_pointes;i++){ // // For each end, we obtain the type of neurite (type_neurite), in a specific color 
				
					if (grand[i]<=minNeurite){									// If  neurite too small, it is deleted of the stack Neurone_use
						selectWindow("Neurone_"+j+"_Neurite"+i+1); close();		
					} 
					
					else {
					selectWindow("Neurone_"+j+"_Neurite"+i+1);
					run("Select None");getStatistics(area, mean, min, max, std, histogram);
						if (mean!=0){
							setThreshold(255, 255);
							run("Create Selection");
							setForegroundColor(type_neurite[i], type_neurite[i], type_neurite[i]);
							run("Fill", "slice");
						} 
					run("Select None");
					}
				}
	
/////////////////////////////////////////Test if their is several neurite to make a stack	//////////////////////////

				o=0;
				for(i=0;i<Nb_pointes;i++){
					if(isOpen("Neurone_"+j+"_Neurite"+i+1)){o++;}
				}
i=0;				

///////////////  Axonal Tree length ////////////////////////////////////////////////////
	if(o==0){ 
	selectWindow("Stack_Neuron_Originale"); setSlice(q); run("Delete Slice");
	selectWindow("Stack_Body"); setSlice(q); run("Delete Slice");
		selectWindow("Stack_NoBodySkelet"); setSlice(q); run("Delete Slice");
	selectWindow("Stack_BodySkelet"); setSlice(q); run("Delete Slice");
		
		
	//print ("la macro est passee par la");
	//setBatchMode("exit and display");
	q=q-1;
	nb_neurones=nb_neurones-1;					
	j=j-1;
	}
	
	if(o>=1){
		if(o==1){// If  one neurite
		for(i=0;i<Nb_pointes;i++){
			if(isOpen("Neurone_"+j+"_Neurite"+i+1)){	
				selectWindow("Neurone_"+j+"_Neurite"+i+1);
				rename("MAX_Neuron_"+j);run("Duplicate...", "title=Axon_total");
				}	}}
				
		if(o>=2){ 									// If more than one neurite on the neuron j >> make a stack
		run("Images to Stack", "name=Neuron_"+j+" title=Neurone_ use");								// Neurite stacks of one neuron
		run("Z Project...", "projection=[Max Intensity]"); run("Duplicate...", "title=Axon_total");	// z projection of neurites on an unique image, and duplication
		selectWindow("Neuron_"+j);close();
		}
		
		selectWindow("Axon_total");
		run("8-bit");
		run("Multiply...", "value=255");
		x=getCoordinate("BX", grand_neurite); y=getCoordinate("BY", grand_neurite);doWand(x, y, 0.0, "8-connected"); // Selection of the longest main tree (axon and connection)
		run("Clear Outside");
		//selectWindow("Results");		IJ.renameResults("Results2");
				
		run("Analyze Skeleton (2D/3D)", "prune=none");
		selectWindow("Results");
		moy=getResult("Average Branch Length", 0);
		n=getResult("# Branches", 0);
		full_axon=moy*n;
		
		close();
		close("Tagged Skeleton");
		//selectWindow("Results2");		IJ.renameResults("Results");

		selectWindow("Axon_total");							
		run("BinaryConnectivity ", "white");
		setThreshold(2, 2); run("Convert to Mask");			
		run("Set Measurements...", "  bounding redirect=None decimal=3");
		run("Analyze Particles...", "size=0-Infinity circularity=0.00-1.00 show=Nothing display clear");
		Nb_branchement =nResults-2;																	// Compute number of branch in this tree 
					
		if(type_neurite[grand_neurite]==1){
			print(j+"\t\t\t\t\t\t  "+full_axon+"\t   "+Nb_branchement);             // Writing results
			nbAxon=nbAxon+1;
		}

		selectWindow("Axon_total");close();	
		selectWindow("MAX_Neuron_"+j);				
		run("neurons"); 																		// Color type for the neurites
		
	}	
		
	q++;		
	endNbNeuron=endNbNeuron+1;
	meanPrimaryLength=push(meanPrimaryLength,MoyPrim);
	meanPrimaryNumber=push(meanPrimaryNumber,NbrPrim);
	
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	
		}}   // Next Neuron

		
run("Images to Stack", "name=Stack_of_Neurones title=MAX use");

selectWindow("Stack_BodySkelet");close();
selectWindow("Stack_NoBodySkelet");close();
	
					
File.makeDirectory(path[e]+"/mesure");


Array.getStatistics(meanPrimaryLength, min, max, meanPL, stdDevPL);
Array.getStatistics(meanPrimaryNumber, min, max, meanPN, stdDevPN);

print ("\t\t\t\t\t\t\t\t------------ Summary ------------");
print ("\t\t\t\t\t\t\t\t Number of mesured neurons :  \t"+endNbNeuron);
print ("\t\t\t\t\t\t\t\t Percentage of neuron with axon :  \t"+nbAxon/endNbNeuron*100+"\t%");
print ("\t\t\t\t\t\t\t\t Mean primary neurite length and stedDev:  \t"+meanPL+"   \t   "+stdDevPL);
print ("\t\t\t\t\t\t\t\t Mean primary neurite number and stedDev:  \t"+meanPN+"   \t   "+stdDevPN);

selectWindow("Log");
saveAs("Text", path[e] +"/mesure/Mesure");
run("Close");
	
selectWindow("Stack_Body");run("neurons");
run("RGB Color");	
selectWindow("Stack_of_Neurones");
run("RGB Color");
selectWindow("Stack_Neuron_Originale");
run("RGB Color");
imageCalculator("Transparent-zero create stack", "Stack_Neuron_Originale","Stack_of_Neurones");
selectWindow("Result of Stack_Neuron_Originale"); rename("Overlay");

imageCalculator("Transparent-zero stack", "Overlay","Stack_Body");
saveAs("tiff", path[e] +"/mesure/Overlay");close();
selectWindow("Stack_of_Neurones");
saveAs("tiff", path[e] +"/mesure/Stack_of_Neurones");
close(); close();

run("Clear Results");
run("Close All");
roiManager("reset");
if (isOpen("Summary")){		selectWindow("Summary");close();}
} // End of condition
	
getDateAndTime(year, month, dayOfWeek, dayOfMonth, hour1, minute1, second, msec);


hourSpent=hour1-hour0;
minSpent=(minute1-minute0)+60*hourSpent;
hourTotal=floor(minSpent/60);
minTotal=minSpent-(hourTotal*60);
print ("programme ran for : "+hourTotal+"h"+minTotal+"min");
	
 } // End of Macro

	
	
//////////////////////////////////////////////// Functions :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	
	
function getCoordinate(column,row) {

	lines = split(coordinates, "\n");
	values = split(lines[row+1], "\t"); /// +1 because the first line is the Title of columns

	if(column== "BX"){return values[1];}//BX
	if(column== "BY"){return values[2];}//BY

}

function push(array,value) {
  a = newArray(array.length+1);
  for(i=0; i<array.length; i++) a[i]= array[i];
  a[a.length-1] = value;
  return a;
}




