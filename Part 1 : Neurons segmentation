/*///This macro was created by Anne BEGHIN, Eric DENARIER and Benoit BOULAN
This was performed on (Fiji Is Just) ImageJ 1.51h version

This macro allow the selection of neurons to quantify the neurite arborescence from mosaic acquisitions 
(stitching of  X20 objective image of a coverslip and binning of 1 or 2 )
It can proceeds several mosaic saved in different folders.

This macro requires in each folder :
		3 images in this order (beware to the naming ) :
		A original image of neurons (e.g neurons.tif)
		A binary image of neurons (e.g neurons_bin.tif)
		A binary image of nucleus (e.g nuclei.tif)

Additional plugins to install in Fiji/plugins: 
		The plugin "Analyze Skeleton 2D/3D"  Developped by Ignacio Arganda-Carreras http://imagej.net/AnalyzeSkeleton
		the Morphology plugins from Gabriel Landini's website : http://www.mecourse.com/landinig/software/software.html

Additional file to install in Fiji/LUT: 
		neurons.lut
		
It creates 6 stacks : 
	Neurones = Stack_Neuron_Original
	Binary Neurons = Stack_Neuron
	Skeletonized = Stack_Skelet
	Cell Body (a circle at the position of the nuclei enlarge to fit the cell body ) = Stack_Body
	Skelet+Cell Body=Stack_BodySkelet
	Skelet-Cell Body= Stack_NobodySkelet
	
	and a ROIset corresponding to the selected neurons on the original image




*/

 macro "AutoNeuriteJ [F1]" {

 
 
 /////////////////////////////// Some parameters to be tuned.
 
minNeuriticTree=10; // Defines the minimal length to be a primary neurite tree if smaller it is erased from the skeleton
minNeuron=1000;  // Defines the minimal area in the binary image to be a neuron if less the neuron is not considered
minLengthSkelet=50; // Defines the minimal length of a neuritic skeleton if smaller the neuron is not considered

Dialog.create("Parameter settings");
Dialog.addNumber("Minimal Area for a binary Neuron :",minNeuron);
Dialog.addNumber("Minimal skeleton length of a neuritic tree :",minNeuriticTree);
Dialog.addNumber("Minimal Total skeleton length to consider a neuron :",minLengthSkelet);
Dialog.show();

minNeuron=Dialog.getNumber();
minNeuriticTree=Dialog.getNumber();
minLengthSkelet=Dialog.getNumber();
 
 
 
 
///////////////////////// Records the time at start of the macro 
 getDateAndTime(year, month, dayOfWeek, dayOfMonth, hour0, minute0, second, msec);
 setBatchMode(true);	
 
//////////////////////////stack opening 
defaultValue=1;
nombre_condition=getNumber("How many conditions do you have to analyze?", defaultValue);
 // Ask for the number of stack to be analysed
path=newArray(nombre_condition);
list=newArray(20);


	

	
for (e=0; e<nombre_condition; e++) {                   // Ask for the directory of each stack to be analysed.
	path[e] = getDirectory("Choose a Directory");
}
	
for (e=0; e<nombre_condition; e++) {                                          // Files opening

list = getFileList(path[e]); titre_culture=File.getName(path[e]);

////////////////////////// Sets information about the cells that will not be considered
number_Neurons=0;
connected_neurons=0;  // Sets the number of connected neurons that will be removed
SkelettooShort=0; // Sets the number of cells with too short skelet that will be removed

		/////////// Opens the original neurons image called Neuron_XXX
		for (fileNumber=0; fileNumber<list.length; fileNumber++) {	
			
			if (startsWith(list[fileNumber], "Neuron_")) {
				open(path[e] + list[fileNumber]);     run("Set Scale...", "distance=1"); rename("Originale"); 
				title2=File.nameWithoutExtension;   											
				run("8-bit"); run("Set Scale...", "distance=1");				
				sauvegarde=File.directory();
				File.makeDirectory(sauvegarde+"/r_"+title2); 
				}

		/////////// Opens the binary neurons image Called Neuron_Bin_XXX and removes on edges and less than minNeuron add to manager
			if (startsWith(list[fileNumber], "NeuronBin_")) {
				open(path[e] + list[fileNumber]); run("Set Scale...", "distance=1"); rename("Binneurons"); run("Select None");
				run("Analyze Particles...", "size="+minNeuron+"-Infinity show=Masks exclude add in_situ");
				}

		/////////// Opens the binary nuclei image Called Nucleus_Bin_XXX
			if (startsWith(list[fileNumber], "Nucleus_Bin_")) {
				open(path[e] + list[fileNumber]); run("Set Scale...", "distance=1");rename("Nuclei");
				}
		}

////////////// Removes Neurons and nuclei when more or less than one nucleus per neuron
	nROI=roiManager("Count");
	
	for (i=0;i<nROI;i++){
		selectWindow("Nuclei");
		roiManager("Select", i); // selection of neurons in ROImanager
		run("Analyze Particles...", "size=0-Infinity summarize"); // counts number of nuclei in the neuron
		}
		
	selectWindow("Summary");
	IJ.renameResults("Results");
	selectWindow("Results");
	
	for (i=0;i<nResults;i++){
	count=getResult("Count",i);
	
		if (count!=1) { // Erases neurons and nuclei when 0 or more than 1 nucleus
		connected_neurons=connected_neurons+count;
		setForegroundColor(0, 0, 0);
		selectWindow("Nuclei");roiManager("Select", i);run("Fill", "slice");run("Select None");
		selectWindow("Binneurons");roiManager("Select", i);run("Fill", "slice");run("Select None");
		}
	}
	
	selectWindow("Results"); run("Close");
	roiManager("reset");

	///////////////////and removes nuclei not in a neuron
imageCalculator("AND", "Nuclei","Binneurons"); 

/////////////// Creates Image of cell bodies by dilating and opening the nuclei in neurons
run("BinaryConditionalDilate ", "mask=Binneurons seed=Nuclei  iterations=10 create white");
run("Options...", "iterations=3 count=1 black do=Open");
run("BinaryConditionalDilate ", "mask=Dilated seed=Nuclei iterations=-1 white"); //removes small bodies after Opening
saveAs("tiff",sauvegarde+"/body_"+title2); rename("Bodies");


////////////////////// Add in ROImanager neurons with a single nucleus

selectWindow("Binneurons"); run("Analyze Particles...", "add");
number_Neurons=roiManager("count");
	
//////////////////////////////////////// Create images of Neurons  (Body-Skelet-BodySkelet-Original-Binarized-NoBodySkelet)//////////////////


		for(j=0;j<number_Neurons;j++){
	
			cutROI ("Originale",j);
			cutROI ("Bodies",j);
			cutROI("Binneurons",j);
			
			////////////////////"Neuron skeleton" images creation from the binarized image////////////////////
			run("Duplicate...", "title=BodSkele_"+j  );
			run("Skeletonize");
			
		
			
			////////////////////"Body and skeleton" and "Skeleton without body" images creation from the binarized image////////////////////
						
			imageCalculator("Add", "BodSkele_"+j ,"Bodies_"+j);
			imageCalculator("Subtract create stack", "BodSkele_"+j,"Bodies_"+j);rename("NoBodySkelet_"+j);

			//////////////////Test if skelet is large enough in NoBodySkelet image //////////////////	
			
			run("Set Measurements...", "area shape limit redirect=None decimal=3");			
			setAutoThreshold("Default dark");
			run("Measure");
			
			lengthSkelet=getResult("Area",0);		
			run("Clear Results");
			
				if (lengthSkelet<= minLengthSkelet) {   //// If length skelet is too short
					selectWindow("Originale_"+j); close();
					selectWindow("Bodies_"+j); close();
					selectWindow("BodSkele_"+j); close();
					SkelettooShort=SkelettooShort+1;
					}

					
////////////////////////////// Removes loops in the neuron's skeleton /////////////////////////////////////////
//// ///////////////////////// We repeat the Skeleton Analysis if a loop is found
				else {   //// If length skelet is long enough
						mean=1;

					while (mean!=0) { mean=analyzeSkeleton("BodSkele_"+j,1);} // prunes the lowest Intensity branch until no more loops
								

// Detection of neurites extremities and substraction to the skeleton to increase distances between extremities 

						selectWindow("BodSkele_"+j); run("Duplicate...", "title=pointes2");	
						run("BinaryConnectivity ", "white");
						setThreshold(2, 2); run("Convert to Mask");	
						imageCalculator("Subtract", "BodSkele_"+j,"pointes2");
 
						selectWindow("pointes2"); close();

			////////////////////////////////////
						mean=1;

						while (mean!=0) { mean=analyzeSkeleton("BodSkele_"+j,2);}	}  // Prunes the shortest branch if a loop is created
					
		
					
					selectWindow("NoBodySkelet_"+j);close();
					// End else if lengthSkelet long enough
call("java.lang.System.gc");    //////Cleans the memory

	} // End of neuron number



roiManager("Deselect");
roiManager("Save", sauvegarde+"/r_"+title2+"/RoiSet.zip"); 
selectWindow("Results"); run("Close"); roiManager("reset");


////////////////////////  Stack creation (Body-Skelet-BodySkelet-NoBodySkelet-Original-Binarized) /////////////////////////////////////////////////////
run("Images to Stack", "method=[Copy (center)] name=Stack_Neuron_Original title=Originale_ use");
run("Images to Stack", "method=[Copy (center)] name=Stack_Neuron title=Binneurons_ use");
run("Images to Stack", "method=[Copy (center)] name=Stack_Body title=Bodies_ use");
run("Images to Stack", "method=[Copy (center)] name=Stack_BodySkelet title=BodSkele_ use");
imageCalculator("Subtract create stack", "Stack_BodySkelet","Stack_Body"); rename("Stack_NoBodySkelet");


// Additional Cleaning of short primary neurite < minNeuriticTree
				selectWindow("Stack_NoBodySkelet");
				nbSlice=nSlices;
				
				for (slice=1;slice<=nbSlice;slice++){
					selectWindow("Stack_NoBodySkelet");
					setSlice(slice);
					run("Analyze Particles...", "add");				
					nROI=roiManager("Count");
					run("Set Measurements...", "area redirect=None decimal=3");
					
					for (i=0;i<nROI;i++){
						selectWindow("Stack_NoBodySkelet");setSlice(slice);
						roiManager("Select", i);
						run("Measure");
						areaNeurite=getResult("Area");
						run("Clear Results");	
						
							if (areaNeurite<=minNeuriticTree){
							setForegroundColor(0, 0, 0);							
							selectWindow("Stack_NoBodySkelet");setSlice(slice);roiManager("Select", i);run("Fill", "slice");														
							}
							
							run("Select None");
					}
				}
				
				selectWindow("Stack_BodySkelet"); close();
				imageCalculator("Add create stack", "Stack_Body","Stack_NoBodySkelet"); rename ("Stack_BodySkelet");
				
				


		
////////////////// Saving and closure of stacks and ROI selections in a file named "resultat" created in the original image path////////////////

print("min Primary Neurite Tree size:   "+minNeuriticTree+"   min Neurons area :     " + minNeuron+"   min Total Skeleton size  :  "+minLengthSkelet);	
print("Neurons with a single nucleus:   "+number_Neurons+"   Number of connected Neurons :     " + connected_neurons+"   Number of Skeleton too short :  "+SkelettooShort);	
print ("Number of neurons considered:   "+number_Neurons-SkelettooShort);		
selectWindow("Log"); saveAs("Text", sauvegarde+"/neurons_count"); run("Close");			

selectWindow("Stack_BodySkelet");run("Remove Overlay");
saveAs("tiff",sauvegarde+"/r_"+title2+"/Stack_BodySkelet"); close();

selectWindow("Stack_Body");
saveAs("tiff",sauvegarde+"/r_"+title2+"/Stack_Body"); close();

selectWindow("Stack_Neuron");run("Remove Overlay");
saveAs("tiff",sauvegarde+"/r_"+title2+"/Stack_Neuron_Bin"); close();

selectWindow("Stack_Neuron_Original");run("Remove Overlay");
saveAs("tiff",sauvegarde+"/r_"+title2+"/Stack_Neuron_Original"); close();

selectWindow("Stack_NoBodySkelet");run("Remove Overlay");
saveAs("tiff",sauvegarde+"/r_"+title2+"/Stack_NoBodySkelet"); close();

call("java.lang.System.gc");    //////Cleans the memory
								

selectWindow("Binneurons"); close();
selectWindow("Originale"); close();
selectWindow("Bodies"); close();
selectWindow("Nuclei"); close();
selectWindow("Results"); run("Close");

if (isOpen("Summary")){		selectWindow("Summary");close();}
run("Close All");
roiManager("reset");
}    //// End of number of conditions
 
 //exit("fini !!!!!");

 //////// Records time at the end of macro and prints the running time
getDateAndTime(year, month, dayOfWeek, dayOfMonth, hour1, minute1, second, msec);

hourSpent=hour1-hour0;
minSpent=(minute1-minute0)+60*hourSpent;
hourTotal=floor(minSpent/60);
minTotal=minSpent-(hourTotal*60);

print ("programme ran for : "+hourTotal+"h"+minTotal+"min");
 
 }


//////////////////////////////////////////////// Functions :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	
	
function cutROI (image,z) {
selectWindow(image);
roiManager("Select", z);
run("Duplicate...", "title="+image+"_"+z);getDimensions(width, height, channels, slices, frames);
setBackgroundColor(0, 0, 0); run("Clear Outside");run("Canvas Size...", "width="+width+2+" height="+height+2+" position=Center");

}

function analyzeSkeleton (image,parameter)	{
						
						selectWindow(image);
						run("Duplicate...", "title=[duplicata]"); 
						selectWindow(image);
						
						if (parameter==1)	run("Analyze Skeleton (2D/3D)", "prune=[lowest intensity branch] original_image=Originale_"+j);
						if (parameter==2)	run("Analyze Skeleton (2D/3D)", "prune=[shortest branch]");
						
						imageCalculator("Subtract create", "duplicata",image);
						selectWindow("Result of duplicata");
						getStatistics(area, moy, min, max, std, histogram);	
						selectWindow("Result of duplicata");	close();
						selectWindow("duplicata");	close();
							if (isOpen("Tagged skeleton")){		selectWindow("Tagged skeleton");close();}
						return moy;
						
							}




